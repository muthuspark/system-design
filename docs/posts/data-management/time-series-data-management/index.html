<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Time-Series Data Management – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-html-5276476b5bdb9cfe1f92c505466e0bf3.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Time-Series Data Management – System Design Notes">
<meta property="og:site_name" content="System Design Notes">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Time-Series Data Management</h1>

</header>


<p>Time-series data, which consists of data points indexed in time order, is a rapidly growing form of data. It is used in a wide range of applications, from sensor readings in IoT devices to financial transactions and website traffic. However, the large volume, velocity, and variety of time-series data creates unique challenges for data management. This post explores the characteristics, challenges, and solutions for managing time-series data.</p>
<h2 id="understanding-the-uniqueness-of-time-series-data" class="anchored">Understanding the Uniqueness of Time-Series Data</h2>
<p>Unlike relational data, which focuses on structured relationships between entities, time-series data emphasizes the temporal aspect. Key characteristics include:</p>
<ul>
<li><strong>High Volume:</strong> Time-series applications often generate massive datasets, often with continuous data streams.</li>
<li><strong>High Velocity:</strong> Data ingestion rates can be extremely high, requiring real-time or near real-time processing capabilities.</li>
<li><strong>High Variety:</strong> Data can come from diverse sources and have different formats (e.g., sensor readings, financial tickers).</li>
<li><strong>High Variability:</strong> Data patterns can be irregular, making analysis and prediction more complex.</li>
</ul>
<h2 id="challenges-in-managing-time-series-data" class="anchored">Challenges in Managing Time-Series Data</h2>
<p>Effectively managing time-series data demands addressing several challenges:</p>
<ul>
<li><strong>Data Storage:</strong> Traditional relational databases struggle with the volume and velocity of time-series data. Specialized databases are often needed.</li>
<li><strong>Data Ingestion:</strong> Real-time ingestion and efficient handling of high-velocity data streams are crucial.</li>
<li><strong>Data Querying:</strong> Efficient querying of large datasets with time-based filters and aggregations is vital for analysis.</li>
<li><strong>Data Processing:</strong> Handling missing data, outliers, and noisy signals requires sophisticated preprocessing and cleaning techniques.</li>
<li><strong>Data Visualization:</strong> Effective visualization of time-series data is essential for understanding trends and patterns.</li>
</ul>
<h2 id="database-solutions-for-time-series-data" class="anchored">Database Solutions for Time-Series Data</h2>
<p>Several database technologies excel at handling time-series data:</p>
<ul>
<li><p><strong><a href="https://www.influxdata.com/">InfluxDB</a>:</strong> An open-source time-series database designed for high-volume, high-velocity data. It offers excellent performance for querying and analyzing time-series data.</p></li>
<li><p><strong><a href="https://www.timescale.com/">TimescaleDB</a>:</strong> An extension of PostgreSQL, combining the robustness of a relational database with optimized time-series capabilities. This allows for complex queries involving both time-series and relational data.</p></li>
<li><p><strong><a href="https://prometheus.io/">Prometheus</a>:</strong> A popular open-source monitoring and alerting toolkit that includes a time-series database. Often used for monitoring infrastructure and applications.</p></li>
</ul>
<p>Here’s a comparison in a simple table:</p>
<table class="caption-top">
<thead>
<tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">InfluxDB</th>
<th style="text-align: left;">TimescaleDB</th>
<th style="text-align: left;">Prometheus</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Type</td>
<td style="text-align: left;">Time-series</td>
<td style="text-align: left;">Relational/TS</td>
<td style="text-align: left;">Time-series</td>
</tr>
<tr class="even">
<td style="text-align: left;">Scalability</td>
<td style="text-align: left;">Excellent</td>
<td style="text-align: left;">Excellent</td>
<td style="text-align: left;">Excellent</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Query Language</td>
<td style="text-align: left;">InfluxQL</td>
<td style="text-align: left;">SQL</td>
<td style="text-align: left;">PromQL</td>
</tr>
<tr class="even">
<td style="text-align: left;">Open Source</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: left;">Yes</td>
<td style="text-align: left;">Yes</td>
</tr>
</tbody>
</table>
<h2 id="data-ingestion-and-processing" class="anchored">Data Ingestion and Processing</h2>
<p>Efficient data ingestion is critical. Many approaches exist:</p>
<ul>
<li><p><strong>Direct Database Insertion:</strong> Data is directly written to the database using the database’s API. This is efficient for smaller datasets.</p></li>
<li><p><strong>Message Queues (Kafka):</strong> High-throughput message queues like Kafka buffer incoming data streams, allowing for decoupling of ingestion and processing. This is ideal for high-velocity data streams.</p></li>
<li><p><strong>Batch Processing (Spark):</strong> For large, offline datasets, batch processing frameworks like Apache Spark can be used for data cleaning, transformation, and feature engineering.</p></li>
</ul>
<p><strong>Illustrative Diagram (Data Ingestion Pipeline):</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    subgraph Data Sources
        S1[IoT Sensors] --&gt; K
        S2[System Metrics] --&gt; K
        S3[Application Logs] --&gt; K
    end

    subgraph Message Queue
        K[Apache Kafka]
    end

    subgraph Processing Layer
        K --&gt; P1[Stream Processing]
        K --&gt; P2[Batch Processing]
        P1 --&gt; DB
        P2 --&gt; DB
    end

    subgraph Storage
        DB[(Time-Series DB)]
    end

    subgraph Analytics
        DB --&gt; V1[Dashboards]
        DB --&gt; V2[Alerts]
        DB --&gt; V3[Reports]
    end

    style S1 fill:#f9f,stroke:#333
    style S2 fill:#f9f,stroke:#333
    style S3 fill:#f9f,stroke:#333
    style K fill:#fcf,stroke:#333
    style DB fill:#9cf,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>This diagram represents a data ingestion pipeline, showcasing the flow of data from various sources to storage and eventual analytics. Here’s an explanation of each component in the context of data ingestion:</p>
<h3 id="data-sources" class="anchored">1. <strong>Data Sources</strong></h3>
<p>The data sources are the origin points where raw data is generated. In this example, there are three different sources:</p>
<ul>
<li><strong>IoT Sensors (S1)</strong>: These devices generate streams of data, such as temperature readings, humidity, or motion detection.</li>
<li><strong>System Metrics (S2)</strong>: Data related to system performance, such as CPU usage, memory consumption, or network traffic.</li>
<li><strong>Application Logs (S3)</strong>: Log files generated by applications, which can include information like error logs, user actions, and performance metrics.</li>
</ul>
<p>Each of these data sources continuously generates data, which is then sent to a <strong>Message Queue</strong> for processing.</p>
<h3 id="message-queue-apache-kafka" class="anchored">2. <strong>Message Queue (Apache Kafka)</strong></h3>
<p>The message queue layer, represented by <a href="https://kafka.apache.org/">Apache Kafka (K)</a>, serves as a highly scalable and fault-tolerant system for collecting and distributing the incoming data. Kafka is responsible for:</p>
<ul>
<li><strong>Ingesting data</strong> from multiple sources in real time.</li>
<li><strong>Decoupling producers (data sources) from consumers (processing systems)</strong>, ensuring a smooth and asynchronous flow of data.</li>
<li><strong>Persisting data streams</strong> temporarily until the next stage is ready to process them.</li>
</ul>
<p>Kafka acts as an intermediary that ensures the data is efficiently routed to the correct processing pipelines.</p>
<h3 id="processing-layer" class="anchored">3. <strong>Processing Layer</strong></h3>
<p>Once the data is in Kafka, it can be processed by two distinct processing mechanisms:</p>
<ul>
<li><p><strong>Stream Processing (P1)</strong>: This involves real-time processing of the incoming data as soon as it arrives. This is suitable for use cases where immediate action is required (e.g., monitoring IoT sensors for anomalies). The processed data is then sent to the storage system.</p></li>
<li><p><strong>Batch Processing (P2)</strong>: This involves processing data in batches at scheduled intervals. It’s suitable for aggregating data over a period and processing it in bulk (e.g., generating daily summaries of system metrics). Like stream processing, the output is sent to the storage system.</p></li>
</ul>
<p>Both stream and batch processing interact with Kafka to fetch the data and pass the results to the storage layer.</p>
<h3 id="storage-time-series-database" class="anchored">4. <strong>Storage (Time-Series Database)</strong></h3>
<p>After the data is processed, it is stored in a <strong>Time-Series Database (DB)</strong>. This type of database is optimized for handling time-stamped data, making it ideal for storing:</p>
<ul>
<li>IoT sensor data with timestamps.</li>
<li>System performance metrics tracked over time.</li>
<li>Logs with time-specific events.</li>
</ul>
<p>A time-series database allows efficient querying and analysis of data based on time ranges, which is crucial for understanding trends and patterns.</p>
<h3 id="analytics" class="anchored">5. <strong>Analytics</strong></h3>
<p>Once data is stored, it can be used for various <strong>analytics</strong> purposes:</p>
<ul>
<li><strong>Dashboards (V1)</strong>: Visualize real-time data in graphical formats (charts, graphs, etc.) for monitoring system performance or sensor readings. Dashboards provide actionable insights at a glance.</li>
<li><strong>Alerts (V2)</strong>: Trigger notifications or alerts based on predefined thresholds. For example, if system metrics exceed certain limits, an alert can be sent to administrators.</li>
<li><strong>Reports (V3)</strong>: Generate detailed reports from historical data, such as weekly or monthly performance summaries.</li>
</ul>
<p>These analytics components depend on the data stored in the time-series database, allowing users to make informed decisions based on real-time and historical insights.</p>
<h2 id="data-querying-and-analysis" class="anchored">Data Querying and Analysis</h2>
<p>Efficient querying is paramount. Time-series databases offer specialized query languages:</p>
<ul>
<li><p><strong>InfluxQL (InfluxDB):</strong> A query language optimized for time-series data.</p></li>
<li><p><strong>PromQL (Prometheus):</strong> A query language focused on monitoring and alerting.</p></li>
<li><p><strong>SQL (TimescaleDB):</strong> Leverages the power and flexibility of SQL for querying both time-series and relational data.</p></li>
</ul>
<h2 id="visualization-and-exploration" class="anchored">Visualization and Exploration</h2>
<p>Effective visualization is crucial for understanding trends and patterns. Tools like Grafana are commonly used to visualize time-series data from various sources, including the databases mentioned above.</p>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>