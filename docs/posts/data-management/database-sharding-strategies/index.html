<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Database Sharding Strategies – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-html-5276476b5bdb9cfe1f92c505466e0bf3.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Database Sharding Strategies – System Design Notes">
<meta property="og:site_name" content="System Design Notes">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Database Sharding Strategies</h1>

</header>


<p>Database sharding is a crucial technique for scaling your database horizontally. When a single database server can no longer handle the volume of data or requests, sharding distributes the data across multiple servers, improving performance and availability. However, choosing the right sharding strategy is critical, as a poorly implemented strategy can lead to performance bottlenecks and operational complexities. This post explores various sharding strategies, their advantages, disadvantages, and implementation considerations.</p>
<h2 id="understanding-the-fundamentals" class="anchored">Understanding the Fundamentals</h2>
<p>Before diving into specific strategies, let’s clarify some key terms:</p>
<ul>
<li><strong>Shard:</strong> A single database server or a group of servers that holds a subset of the total data.</li>
<li><strong>Shard Key:</strong> A field or a combination of fields used to determine which shard a particular data record belongs to.</li>
<li><strong>Shard Routing:</strong> The mechanism that determines which shard to query based on the shard key.</li>
<li><strong>Data Distribution:</strong> The method of distributing data across shards.</li>
<li><strong>Global Index:</strong> An index that spans across all shards, required for certain types of queries.</li>
</ul>
<h2 id="common-sharding-strategies" class="anchored">Common Sharding Strategies</h2>
<p>Several popular strategies exist for sharding a database. The best choice depends on your specific data model, query patterns, and application requirements.</p>
<h3 id="range-based-sharding" class="anchored">1. Range-Based Sharding</h3>
<p>In range-based sharding, the shard key’s value range is divided amongst the shards. For example, if your shard key is <code>user_id</code>, you might assign shards as follows:</p>
<ul>
<li>Shard 1: <code>user_id</code> from 1 to 1000</li>
<li>Shard 2: <code>user_id</code> from 1001 to 2000</li>
<li>Shard 3: <code>user_id</code> from 2001 to 3000</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A[Application] --&gt; B[Router]
    B --&gt; C{Range Check}
    
    subgraph "Sharding Rules"
        C --&gt;|1-1000| D[Shard 1]
        C --&gt;|1001-2000| E[Shard 2]
        C --&gt;|2001-3000| F[Shard 3]
    end
    
    subgraph "Shard 1: US Users"
        D --&gt; D1[user_id: 125&lt;br/&gt;region: US&lt;br/&gt;name: John]
        D --&gt; D2[user_id: 850&lt;br/&gt;region: US&lt;br/&gt;name: Alice]
    end
    
    subgraph "Shard 2: EU Users"
        E --&gt; E1[user_id: 1200&lt;br/&gt;region: EU&lt;br/&gt;name: Pierre]
        E --&gt; E2[user_id: 1750&lt;br/&gt;region: EU&lt;br/&gt;name: Maria]
    end
    
    subgraph "Shard 3: ASIA Users"
        F --&gt; F1[user_id: 2100&lt;br/&gt;region: ASIA&lt;br/&gt;name: Li]
        F --&gt; F2[user_id: 2900&lt;br/&gt;region: ASIA&lt;br/&gt;name: Raj]
    end
    
    style D fill:#90EE90
    style E fill:#87CEEB
    style F fill:#FFB6C1
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Key aspects:</p>
<ol type="1">
<li>Sharding Logic:</li>
</ol>
<ul>
<li>Shard 1: IDs 1-1000 (US users)</li>
<li>Shard 2: IDs 1001-2000 (EU users)</li>
<li>Shard 3: IDs 2001-3000 (ASIA users)</li>
</ul>
<ol start="2" type="1">
<li>Benefits:</li>
</ol>
<ul>
<li>Sequential data access</li>
<li>Geographic data locality</li>
<li>Simple range queries</li>
<li>Easy to add new ranges</li>
</ul>
<ol start="3" type="1">
<li>Considerations:</li>
</ol>
<ul>
<li>Potential for uneven distribution</li>
<li>Hot spots in sequential inserts</li>
<li>Range boundaries need careful planning</li>
</ul>
<p><strong>Advantages:</strong> Simple to implement and understand.</p>
<p><strong>Disadvantages:</strong> Can lead to hotspots if data distribution is uneven. Adding or removing shards can be complex and require significant data migration. Range queries across multiple shards can be inefficient.</p>
<h3 id="hash-based-sharding" class="anchored">2. Hash-Based Sharding</h3>
<p>Hash-based sharding uses a hash function to distribute data across shards. The hash function maps the shard key to a shard ID. This offers better data distribution than range-based sharding.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A[Application] --&gt; B[Router]
    B --&gt; C{Hash Function}
    
    subgraph "Sharding Logic"
        C --&gt;|user_id % 3 = 0| D[Shard 1]
        C --&gt;|user_id % 3 = 1| E[Shard 2]
        C --&gt;|user_id % 3 = 2| F[Shard 3]
    end
    
    subgraph "Shard 1 Data"
        D --&gt; D1[user_id: 3]
        D --&gt; D2[user_id: 6]
    end
    
    subgraph "Shard 2 Data"
        E --&gt; E1[user_id: 1]
        E --&gt; E2[user_id: 4]
    end
    
    subgraph "Shard 3 Data"
        F --&gt; F1[user_id: 2]
        F --&gt; F2[user_id: 5]
    end
    
    style D fill:#90EE90
    style E fill:#87CEEB
    style F fill:#FFB6C1
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Components:</p>
<ol type="1">
<li>Router: Directs requests based on shard key</li>
<li>Hash Function: Determines shard placement using modulo</li>
<li>Shards: Distributed data stores</li>
</ol>
<p>Flow:</p>
<ol type="1">
<li>Application sends request with user_id</li>
<li>Router applies hash function (user_id % 3)</li>
<li>Request routed to appropriate shard</li>
<li>Data stored/retrieved from specific shard</li>
</ol>
<p>Benefits:</p>
<ul>
<li>Horizontal scalability</li>
<li>Better performance</li>
<li>Load distribution</li>
<li>Data locality</li>
</ul>
<h3 id="directory-based-sharding-consistent-hashing" class="anchored">3. Directory-Based Sharding (Consistent Hashing)</h3>
<p>Directory-based sharding uses a consistent hashing algorithm to map shard keys to shards. This improves scalability and simplifies adding or removing shards without requiring large-scale data migration. A central directory or metadata service keeps track of the mapping between shard keys and shard locations.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TD
    A[Application] --&gt; B[Directory Service]
    B --&gt; C[Hash Ring]
    
    subgraph "Hash Ring Distribution"
        C --&gt;|0-90°| D[Node 1]
        C --&gt;|91-180°| E[Node 2]
        C --&gt;|181-270°| F[Node 3]
        C --&gt;|271-360°| G[Node 4]
    end
    
    subgraph "Virtual Nodes"
        D --&gt; D1[VNode 1.1&lt;br/&gt;Range: 0-45°]
        D --&gt; D2[VNode 1.2&lt;br/&gt;Range: 46-90°]
        E --&gt; E1[VNode 2.1&lt;br/&gt;Range: 91-135°]
        E --&gt; E2[VNode 2.2&lt;br/&gt;Range: 136-180°]
    end
    
    subgraph "Data Distribution"
        D1 --&gt; X1[key1: value1]
        D2 --&gt; X2[key2: value2]
        E1 --&gt; X3[key3: value3]
        E2 --&gt; X4[key4: value4]
    end
    
    style D fill:#90EE90
    style E fill:#87CEEB
    style F fill:#FFB6C1
    style G fill:#DDA0DD

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Key Components:</p>
<ol type="1">
<li>Directory Service: Maintains mapping of data locations</li>
<li>Hash Ring: 360° circle divided among nodes</li>
<li>Virtual Nodes: Multiple points per physical node for better distribution</li>
<li>Data Distribution: Keys mapped to nearest node clockwise</li>
</ol>
<p>Advantages:</p>
<ul>
<li>Minimal data movement when scaling</li>
<li>Even distribution</li>
<li>Automatic failover</li>
<li>Dynamic node addition/removal</li>
</ul>
<p>When adding/removing nodes, only neighboring nodes are affected, making scaling operations efficient.</p>
<h3 id="key-based-sharding" class="anchored">4. Key-Based Sharding</h3>
<p>This strategy assigns shards based on specific key values or patterns in the shard key. For instance, you might assign all users from a specific region to a single shard.</p>
<p><strong>Advantages:</strong> Can be efficient for queries related to the key used for sharding.</p>
<p><strong>Disadvantages:</strong> Can lead to uneven distribution and hotspots if not carefully planned. Adding new shards requires careful consideration of key distribution.</p>
<h2 id="choosing-the-right-strategy" class="anchored">Choosing the Right Strategy</h2>
<p>The optimal sharding strategy depends on your application’s specific needs. Consider the following factors:</p>
<ul>
<li><strong>Data distribution:</strong> How evenly is your data distributed across the potential shard keys?</li>
<li><strong>Query patterns:</strong> What types of queries are most common in your application (e.g., point lookups, range queries)?</li>
<li><strong>Scalability requirements:</strong> How much do you expect your data to grow?</li>
<li><strong>Operational complexity:</strong> How much operational overhead are you willing to accept?</li>
</ul>
<h3 id="comparison-of-database-sharding-strategies-features-and-trade-offs" class="anchored"><strong>Comparison of Database Sharding Strategies: Features and Trade-offs</strong></h3>
<table class="caption-top" style="width:100%;">
<colgroup>
<col style="width: 19%">
<col style="width: 22%">
<col style="width: 26%">
<col style="width: 31%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Feature</th>
<th style="text-align: left;">Hash-Based</th>
<th style="text-align: left;">Range-Based</th>
<th style="text-align: left;">Directory-Based</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;">Data Distribution</td>
<td style="text-align: left;">Very even</td>
<td style="text-align: left;">Can be uneven</td>
<td style="text-align: left;">Even</td>
</tr>
<tr class="even">
<td style="text-align: left;">Query Patterns</td>
<td style="text-align: left;">Point lookups</td>
<td style="text-align: left;">Range queries</td>
<td style="text-align: left;">Both point and range</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Scalability</td>
<td style="text-align: left;">High</td>
<td style="text-align: left;">Medium</td>
<td style="text-align: left;">Very High</td>
</tr>
<tr class="even">
<td style="text-align: left;">Operational Complexity</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Medium</td>
<td style="text-align: left;">High</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Hot Spots</td>
<td style="text-align: left;">Rare</td>
<td style="text-align: left;">Common</td>
<td style="text-align: left;">Managed</td>
</tr>
<tr class="even">
<td style="text-align: left;">Data Locality</td>
<td style="text-align: left;">Random</td>
<td style="text-align: left;">Good</td>
<td style="text-align: left;">Configurable</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Rebalancing</td>
<td style="text-align: left;">Complex</td>
<td style="text-align: left;">Simple</td>
<td style="text-align: left;">Dynamic</td>
</tr>
<tr class="even">
<td style="text-align: left;">Node Addition</td>
<td style="text-align: left;">Requires rehashing</td>
<td style="text-align: left;">Easy</td>
<td style="text-align: left;">Minimal impact</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Range Queries</td>
<td style="text-align: left;">Poor</td>
<td style="text-align: left;">Excellent</td>
<td style="text-align: left;">Good</td>
</tr>
<tr class="even">
<td style="text-align: left;">Best For</td>
<td style="text-align: left;">Uniform data access</td>
<td style="text-align: left;">Sequential data access</td>
<td style="text-align: left;">Dynamic environments</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Infrastructure Needs</td>
<td style="text-align: left;">Minimal</td>
<td style="text-align: left;">Basic</td>
<td style="text-align: left;">Advanced</td>
</tr>
<tr class="even">
<td style="text-align: left;">Maintenance</td>
<td style="text-align: left;">Low</td>
<td style="text-align: left;">Medium</td>
<td style="text-align: left;">High</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Geographic Distribution</td>
<td style="text-align: left;">Limited</td>
<td style="text-align: left;">Natural</td>
<td style="text-align: left;">Flexible</td>
</tr>
<tr class="even">
<td style="text-align: left;">Load Balancing</td>
<td style="text-align: left;">Automatic</td>
<td style="text-align: left;">Manual</td>
<td style="text-align: left;">Semi-automatic</td>
</tr>
<tr class="odd">
<td style="text-align: left;">Failure Recovery</td>
<td style="text-align: left;">Complex</td>
<td style="text-align: left;">Simple</td>
<td style="text-align: left;">Advanced</td>
</tr>
</tbody>
</table>
<p><strong>The key differences between sharding strategies:</strong></p>
<p>Hash-Based Sharding:</p>
<ul>
<li>Evenly distributes data using hash functions</li>
<li>Excellent for uniform data access and point queries</li>
<li>Limited in range queries and data locality</li>
<li>Requires complete rehashing when adding nodes</li>
</ul>
<p>Range-Based Sharding:</p>
<ul>
<li>Organizes data in sequential ranges</li>
<li>Perfect for range queries and geographic distribution</li>
<li>Prone to hot spots and uneven distribution</li>
<li>Simple to maintain and add new nodes</li>
</ul>
<p>Directory-Based Sharding:</p>
<ul>
<li>Most flexible but complex solution</li>
<li>Supports both range and point queries effectively</li>
<li>Excellent scalability with minimal disruption</li>
<li>Requires additional infrastructure and maintenance</li>
<li>Best for dynamic environments needing frequent scaling</li>
</ul>
<p>Key Trade-offs:</p>
<ul>
<li>Complexity vs Flexibility: Hash-Based is simplest, Directory-Based most flexible</li>
<li>Performance vs Features: Range-Based best for sequential access, Hash-Based for uniform distribution</li>
<li>Maintenance vs Scalability: Directory-Based offers best scaling but highest maintenance</li>
</ul>
<h2 id="implementation-considerations" class="anchored">Implementation Considerations</h2>
<p>Implementing sharding effectively requires careful planning and execution. Key aspects include:</p>
<ul>
<li><strong>Shard key selection:</strong> Choose a shard key that is highly selective and leads to even data distribution.</li>
<li><strong>Data migration:</strong> Plan for efficient data migration during initial sharding and when adding or removing shards.</li>
<li><strong>Global indexes:</strong> Consider whether global indexes are needed for your query patterns.</li>
<li><strong>Transaction management:</strong> Ensure proper transaction management across multiple shards.</li>
<li><strong>Monitoring and management:</strong> Implement robust monitoring and management tools to track shard health, performance, and data distribution.</li>
</ul>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>