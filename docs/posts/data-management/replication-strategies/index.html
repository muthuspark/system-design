<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Replication Strategies – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5c1aa57916d092647891b8a3fe59897e.min.css" rel="stylesheet" append-hash="true" class="quarto-color-scheme" id="quarto-bootstrap" data-mode="light">
<link href="../../../site_libs/bootstrap/bootstrap-dark-ee5e052b81fc94e1f9bb89611f476562.min.css" rel="prefetch" append-hash="true" class="quarto-color-scheme quarto-color-alternate" id="quarto-bootstrap" data-mode="dark">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Replication Strategies – System Design Notes">
<meta property="og:description" content="">
<meta property="og:site_name" content="System Design Notes">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">System Design Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/muthuspark"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/krimuthu"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-color-scheme-toggle quarto-navigation-tool  px-1" onclick="window.quartoToggleColorScheme(); return false;" title="Toggle dark mode"><i class="bi"></i></a>
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">Replication Strategies</h1>
  <div class="quarto-categories">
    <div class="quarto-category">Data Management</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>Data replication is an important aspect of building reliable systems. It involves creating copies of data and storing them in multiple locations. This strategy offers many advantages, including increased availability, improved performance, and enhanced data protection against failures. However, choosing the right replication strategy is critical, as it directly impacts system performance, complexity, and cost. This post explores various replication strategies, exploring their strengths, weaknesses, and practical applications.</p>
<section id="types-of-replication-strategies" class="level2">
<h2 data-anchor-id="types-of-replication-strategies">Types of Replication Strategies</h2>
<p>Several replication strategies exist, each with its own trade-offs. Let’s examine some of the most common ones:</p>
<section id="synchronous-replication" class="level3">
<h3 data-anchor-id="synchronous-replication">1. Synchronous Replication</h3>
<p>Synchronous replication guarantees data consistency across all replicas. Before acknowledging a write operation as successful, the primary server waits for confirmation from all secondary servers that the data has been written successfully.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High data consistency:</strong> All replicas are always in sync.</li>
<li><strong>High data durability:</strong> Data loss is minimized as data is written to multiple locations.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Reduced write performance:</strong> The write operation is only completed after all replicas acknowledge, leading to slower write speeds.</li>
<li><strong>Single point of failure:</strong> If the primary server fails, writes become impossible until a new primary is elected.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
    end

    subgraph Primary
        P[Primary Node] --&gt; S1
        P --&gt; S2
        P --&gt; S3
    end

    subgraph Secondaries
        S1[Secondary 1]
        S2[Secondary 2]
        S3[Secondary 3]
    end

    S1 -.-&gt;|Acknowledge| P
    S2 -.-&gt;|Acknowledge| P
    S3 -.-&gt;|Acknowledge| P
    
    P -.-&gt;|Success| W

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#9cf,stroke:#333
    style S3 fill:#9cf,stroke:#333
    style W fill:#f9f,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram illustrates:</p>
<p><strong>1. Write Request (Pink circle):</strong></p>
<ul>
<li>Initial client write request enters the system</li>
</ul>
<p><strong>2. Primary Node (Orange):</strong></p>
<ul>
<li>Receives write requests</li>
<li>Coordinates replication to secondaries</li>
<li>Ensures data consistency</li>
</ul>
<p><strong>3. Secondary Nodes (Blue):</strong></p>
<ul>
<li>Maintain synchronized copies of data</li>
<li>Send acknowledgments back to primary</li>
<li>Provide redundancy and failover capability</li>
</ul>
<p><strong>4. Data Flow:</strong></p>
<ul>
<li>Solid lines: Write propagation from primary to secondaries</li>
<li>Dotted lines: Acknowledgment messages back to primary</li>
<li>Final dotted line: Success confirmation to client</li>
</ul>
<p>This architecture ensures data consistency and fault tolerance through synchronized replication.</p>
</section>
<section id="asynchronous-replication" class="level3">
<h3 data-anchor-id="asynchronous-replication">2. Asynchronous Replication</h3>
<p>Asynchronous replication prioritizes write performance over strict consistency. The primary server writes data without waiting for confirmation from secondary servers. Secondary servers update themselves periodically or based on events.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High write performance:</strong> Write operations are much faster as they don’t wait for replication.</li>
<li><strong>Improved scalability:</strong> Adding or removing secondary servers has minimal impact on performance.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Data inconsistency:</strong> Data might be inconsistent across replicas for a short period.</li>
<li><strong>Data loss risk:</strong> If the primary server fails before data is replicated, data loss can occur.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
        P -.-&gt;|Immediate Success| W
    end

    subgraph Primary
        P[Primary Node]
    end

    subgraph Async Replication
        P --&gt; |Async| S1[Secondary 1]
        P --&gt; |Async| S2[Secondary 2]
        P --&gt; |Async| S3[Secondary 3]
    end

    subgraph Status Updates
        S1 -.-&gt;|Replication Status| P
        S2 -.-&gt;|Replication Status| P
        S3 -.-&gt;|Replication Status| P
    end

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#9cf,stroke:#333
    style S3 fill:#9cf,stroke:#333
    style W fill:#f9f,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram shows:</p>
<p><strong>1. Write Flow (Pink):</strong></p>
<ul>
<li>Client sends write request to Primary</li>
<li>Primary confirms immediately, without waiting for secondaries</li>
</ul>
<p><strong>2. Primary Node (Orange):</strong></p>
<ul>
<li>Handles incoming writes</li>
<li>Propagates changes asynchronously to secondaries</li>
</ul>
<p><strong>3. Secondary Nodes (Blue):</strong></p>
<ul>
<li>Receive updates asynchronously</li>
<li>Send periodic status updates to Primary</li>
<li>May lag behind Primary</li>
</ul>
<p>This design prioritizes write performance over immediate consistency.</p>
</section>
<section id="semi-synchronous-replication" class="level3">
<h3 data-anchor-id="semi-synchronous-replication">3. Semi-Synchronous Replication</h3>
<p>Semi-synchronous replication offers a compromise between synchronous and asynchronous replication. The primary server waits for confirmation from at least one secondary server before acknowledging the write operation.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Improved write performance:</strong> Faster than synchronous replication.</li>
<li><strong>Enhanced data durability:</strong> Better data protection than asynchronous replication.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Potential for data inconsistency:</strong> If the only confirmed secondary server fails before replicating to other servers, inconsistency may arise.</li>
<li><strong>Performance can degrade if confirmed secondary servers are unavailable</strong></li>
</ul>
<p><strong>Diagram:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
    end

    subgraph Primary
        P[Primary Node]
    end

    subgraph Required Sync
        P --&gt; |Sync| S1[Secondary 1]
        S1 -.-&gt;|Acknowledge| P
    end

    subgraph Async Replicas
        P --&gt; |Async| S2[Secondary 2]
        P --&gt; |Async| S3[Secondary 3]
        S2 -.-&gt;|Status Update| P
        S3 -.-&gt;|Status Update| P
    end

    P -.-&gt;|Success after S1| W

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#ddd,stroke:#333
    style S3 fill:#ddd,stroke:#333
    style W fill:#f9f,stroke:#333

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram illustrates:</p>
<p><strong>1. Write Process:</strong></p>
<ul>
<li>Client sends write request to Primary (Orange)</li>
<li>Primary syncs with Secondary 1 (Blue)</li>
<li>Secondary 1 must acknowledge before success</li>
</ul>
<p><strong>2. Secondary Nodes:</strong></p>
<ul>
<li>Secondary 1: Synchronous replication, required for write confirmation</li>
<li>Secondary 2 &amp; 3 (Gray): Asynchronous updates, not required for confirmation</li>
</ul>
<p><strong>3. Success Flow:</strong></p>
<ul>
<li>Write confirmed after Primary and Secondary 1 sync</li>
<li>Provides balance between data safety and performance</li>
<li>Other secondaries update eventually</li>
</ul>
<p>This hybrid approach ensures at least one backup is current while maintaining reasonable write speeds.</p>
</section>
<section id="multi-master-replication" class="level3">
<h3 data-anchor-id="multi-master-replication">4. Multi-Master Replication</h3>
<p>In multi-master replication, multiple servers can act as primary servers, accepting writes independently. Conflict resolution mechanisms are required to ensure data consistency across all replicas.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High availability:</strong> Writes can be accepted even if some servers are unavailable.</li>
<li><strong>Geographic distribution:</strong> Ideal for geographically distributed applications.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Complex conflict resolution:</strong> Requires complex mechanisms to handle concurrent writes.</li>
<li><strong>Increased complexity:</strong> Managing multiple masters increases operational overhead.</li>
</ul>
<p><strong>Diagram:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[Master Server 1] --&gt; B(Replica);
    C[Master Server 2] --&gt; B;
    D[Master Server 3] --&gt; B;
    A -.-&gt; C;
    A -.-&gt; D;
    C -.-&gt; A;
    C -.-&gt; D;
    D -.-&gt; A;
    D -.-&gt; C;
    style A fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#ccf,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Here’s the information presented in a markdown table format, followed by a more detailed explanation:</p>
</section>
</section>
<section id="choosing-the-right-replication-strategy" class="level2">
<h2 data-anchor-id="choosing-the-right-replication-strategy">Choosing the Right Replication Strategy</h2>
<table class="caption-top table">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Factor</th>
<th style="text-align: left;">Key Considerations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Data consistency</strong></td>
<td style="text-align: left;">How important is it that all replicas reflect the same data at all times (strong vs.&nbsp;eventual consistency)?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Performance needs</strong></td>
<td style="text-align: left;">How much latency can be tolerated for reads and writes? Is fast read access prioritized over write performance or vice versa?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Availability requirements</strong></td>
<td style="text-align: left;">How much downtime can the system afford? Is high availability essential?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Cost considerations</strong></td>
<td style="text-align: left;">What are the associated infrastructure, resource, and maintenance costs of each replication strategy?</td>
</tr>
</tbody>
</table>
<section id="data-consistency-requirements" class="level4">
<h4 data-anchor-id="data-consistency-requirements">1. <strong>Data Consistency Requirements</strong></h4>
<p>When choosing a replication strategy, one of the most critical considerations is <strong>data consistency</strong>—the guarantee that all replicas reflect the same data. Two main types of consistency are:</p>
<ul>
<li><p><strong>Strong consistency</strong>: Ensures that once data is written to a primary node, all replicas immediately reflect that update. This is ideal for systems that require accurate, up-to-the-second data (e.g., financial transactions), but may come with higher latency as the system waits for all replicas to sync.</p></li>
<li><p><strong>Eventual consistency</strong>: Guarantees that replicas will eventually sync up, but not immediately. This strategy is more scalable and performs better for applications where real-time consistency is not critical, such as social media or e-commerce product catalogs.</p></li>
</ul>
<p>Choosing between these depends on how important it is that replicas remain synchronized at all times. For example, in mission-critical systems (like banking), strong consistency is often required. In contrast, in applications where slight delays in replica synchronization are acceptable (like social media posts), eventual consistency may be more suitable.</p>
</section>
<section id="performance-needs" class="level4">
<h4 data-anchor-id="performance-needs">2. <strong>Performance Needs</strong></h4>
<p>Performance is another key consideration in replication strategies:</p>
<ul>
<li><strong>Write performance</strong>: Replicating data across multiple nodes can introduce latency in write operations, especially in synchronous replication systems (where updates must be written to all replicas simultaneously). If your application needs to process a high volume of writes with minimal latency (e.g., real-time analytics), then a strategy that reduces replication overhead during writes is important.</li>
</ul>
<p><strong>Read performance</strong>: In read-heavy systems, replication can improve read performance by distributing requests across multiple replicas. For example, applications like content delivery networks (CDNs) can use replication to serve users from the nearest replica, reducing latency.</p>
<p>In general, if the application is <strong>read-heavy</strong> (e.g., news sites or product search), replication strategies that optimize for read scalability (such as eventual consistency) can be beneficial. For <strong>write-heavy</strong> systems, synchronous replication may pose performance challenges and must be carefully considered.</p>
</section>
<section id="availability-requirements" class="level4">
<h4 data-anchor-id="availability-requirements">3. <strong>Availability Requirements</strong></h4>
<p>Replication also plays a key role in ensuring <strong>high availability</strong>—the ability to keep the system operational even if individual nodes fail. Different replication strategies provide varying levels of fault tolerance and availability.</p>
<ul>
<li><p><strong>Synchronous replication</strong>: Writes are replicated to multiple nodes simultaneously, ensuring that any node failure doesn’t result in data loss. However, synchronous replication can increase latency and impact performance.</p></li>
<li><p><strong>Asynchronous replication</strong>: Writes are replicated to a primary node first, and then propagated to replicas later. This approach minimizes latency but increases the risk of data loss if the primary node fails before replication is complete.</p></li>
</ul>
<p>Systems with strict <strong>availability requirements</strong> (such as those needing 24/7 uptime) should favor strategies with strong fault tolerance. Asynchronous replication may be acceptable in less critical applications or where cost and performance are more important than immediate availability.</p>
</section>
<section id="cost-considerations" class="level4">
<h4 data-anchor-id="cost-considerations">4. <strong>Cost Considerations</strong></h4>
<p>Each replication strategy comes with different cost implications:</p>
<ul>
<li><p><strong>Infrastructure costs</strong>: Maintaining multiple replicas requires additional hardware or cloud resources. More replicas (especially in a synchronous setup) can increase these costs substantially.</p></li>
<li><p><strong>Maintenance and complexity</strong>: More complex replication strategies (e.g., multi-region synchronous replication) introduce operational complexity. This can increase the need for skilled personnel, monitoring, and advanced tooling.</p></li>
</ul>
<p>When choosing a replication strategy, the trade-offs between cost and performance need to be evaluated. For instance, highly consistent, highly available systems with low latency may require significant investments in infrastructure, while eventual consistency strategies might be more affordable.</p>


</section>
</section>

</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const disableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'prefetch';
    }
  }
  const enableStylesheet = (stylesheets) => {
    for (let i=0; i < stylesheets.length; i++) {
      const stylesheet = stylesheets[i];
      stylesheet.rel = 'stylesheet';
    }
  }
  const manageTransitions = (selector, allowTransitions) => {
    const els = window.document.querySelectorAll(selector);
    for (let i=0; i < els.length; i++) {
      const el = els[i];
      if (allowTransitions) {
        el.classList.remove('notransition');
      } else {
        el.classList.add('notransition');
      }
    }
  }
  const toggleGiscusIfUsed = (isAlternate, darkModeDefault) => {
    const baseTheme = document.querySelector('#giscus-base-theme')?.value ?? 'light';
    const alternateTheme = document.querySelector('#giscus-alt-theme')?.value ?? 'dark';
    let newTheme = '';
    if(darkModeDefault) {
      newTheme = isAlternate ? baseTheme : alternateTheme;
    } else {
      newTheme = isAlternate ? alternateTheme : baseTheme;
    }
    const changeGiscusTheme = () => {
      // From: https://github.com/giscus/giscus/issues/336
      const sendMessage = (message) => {
        const iframe = document.querySelector('iframe.giscus-frame');
        if (!iframe) return;
        iframe.contentWindow.postMessage({ giscus: message }, 'https://giscus.app');
      }
      sendMessage({
        setConfig: {
          theme: newTheme
        }
      });
    }
    const isGiscussLoaded = window.document.querySelector('iframe.giscus-frame') !== null;
    if (isGiscussLoaded) {
      changeGiscusTheme();
    }
  }
  const toggleColorMode = (alternate) => {
    // Switch the stylesheets
    const alternateStylesheets = window.document.querySelectorAll('link.quarto-color-scheme.quarto-color-alternate');
    manageTransitions('#quarto-margin-sidebar .nav-link', false);
    if (alternate) {
      enableStylesheet(alternateStylesheets);
      for (const sheetNode of alternateStylesheets) {
        if (sheetNode.id === "quarto-bootstrap") {
          toggleBodyColorMode(sheetNode);
        }
      }
    } else {
      disableStylesheet(alternateStylesheets);
      toggleBodyColorPrimary();
    }
    manageTransitions('#quarto-margin-sidebar .nav-link', true);
    // Switch the toggles
    const toggles = window.document.querySelectorAll('.quarto-color-scheme-toggle');
    for (let i=0; i < toggles.length; i++) {
      const toggle = toggles[i];
      if (toggle) {
        if (alternate) {
          toggle.classList.add("alternate");     
        } else {
          toggle.classList.remove("alternate");
        }
      }
    }
    // Hack to workaround the fact that safari doesn't
    // properly recolor the scrollbar when toggling (#1455)
    if (navigator.userAgent.indexOf('Safari') > 0 && navigator.userAgent.indexOf('Chrome') == -1) {
      manageTransitions("body", false);
      window.scrollTo(0, 1);
      setTimeout(() => {
        window.scrollTo(0, 0);
        manageTransitions("body", true);
      }, 40);  
    }
  }
  const isFileUrl = () => { 
    return window.location.protocol === 'file:';
  }
  const hasAlternateSentinel = () => {  
    let styleSentinel = getColorSchemeSentinel();
    if (styleSentinel !== null) {
      return styleSentinel === "alternate";
    } else {
      return false;
    }
  }
  const setStyleSentinel = (alternate) => {
    const value = alternate ? "alternate" : "default";
    if (!isFileUrl()) {
      window.localStorage.setItem("quarto-color-scheme", value);
    } else {
      localAlternateSentinel = value;
    }
  }
  const getColorSchemeSentinel = () => {
    if (!isFileUrl()) {
      const storageValue = window.localStorage.getItem("quarto-color-scheme");
      return storageValue != null ? storageValue : localAlternateSentinel;
    } else {
      return localAlternateSentinel;
    }
  }
  const darkModeDefault = false;
  let localAlternateSentinel = darkModeDefault ? 'alternate' : 'default';
  // Dark / light mode switch
  window.quartoToggleColorScheme = () => {
    // Read the current dark / light value 
    let toAlternate = !hasAlternateSentinel();
    toggleColorMode(toAlternate);
    setStyleSentinel(toAlternate);
    toggleGiscusIfUsed(toAlternate, darkModeDefault);
  };
  // Ensure there is a toggle, if there isn't float one in the top right
  if (window.document.querySelector('.quarto-color-scheme-toggle') === null) {
    const a = window.document.createElement('a');
    a.classList.add('top-right');
    a.classList.add('quarto-color-scheme-toggle');
    a.href = "";
    a.onclick = function() { try { window.quartoToggleColorScheme(); } catch {} return false; };
    const i = window.document.createElement("i");
    i.classList.add('bi');
    a.appendChild(i);
    window.document.body.appendChild(a);
  }
  // Switch to dark mode if need be
  if (hasAlternateSentinel()) {
    toggleColorMode(true);
  } else {
    toggleColorMode(false);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
});
</script>
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>Copyright 2025, Muthukrishnan</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>