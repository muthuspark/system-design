<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Replication Strategies – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-html-5276476b5bdb9cfe1f92c505466e0bf3.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Replication Strategies – System Design Notes">
<meta property="og:site_name" content="System Design Notes">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Replication Strategies</h1>

</header>


<p>Data replication is a crucial aspect of building robust and reliable systems. It involves creating copies of data and storing them in multiple locations. This strategy offers several advantages, including increased availability, improved performance, and enhanced data protection against failures. However, choosing the right replication strategy is critical, as it directly impacts system performance, complexity, and cost. This post dives deep into various replication strategies, exploring their strengths, weaknesses, and practical applications.</p>
<h2 id="types-of-replication-strategies" class="anchored">Types of Replication Strategies</h2>
<p>Several replication strategies exist, each with its own trade-offs. Let’s examine some of the most common ones:</p>
<h3 id="synchronous-replication" class="anchored">1. Synchronous Replication</h3>
<p>Synchronous replication guarantees data consistency across all replicas. Before acknowledging a write operation as successful, the primary server waits for confirmation from all secondary servers that the data has been written successfully.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High data consistency:</strong> All replicas are always in sync.</li>
<li><strong>High data durability:</strong> Data loss is minimized as data is written to multiple locations.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Reduced write performance:</strong> The write operation is only completed after all replicas acknowledge, leading to slower write speeds.</li>
<li><strong>Single point of failure:</strong> If the primary server fails, writes become impossible until a new primary is elected.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
    end

    subgraph Primary
        P[Primary Node] --&gt; S1
        P --&gt; S2
        P --&gt; S3
    end

    subgraph Secondaries
        S1[Secondary 1]
        S2[Secondary 2]
        S3[Secondary 3]
    end

    S1 -.-&gt;|Acknowledge| P
    S2 -.-&gt;|Acknowledge| P
    S3 -.-&gt;|Acknowledge| P
    
    P -.-&gt;|Success| W

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#9cf,stroke:#333
    style S3 fill:#9cf,stroke:#333
    style W fill:#f9f,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram illustrates:</p>
<p><strong>1. Write Request (Pink circle):</strong></p>
<ul>
<li>Initial client write request enters the system</li>
</ul>
<p><strong>2. Primary Node (Orange):</strong></p>
<ul>
<li>Receives write requests</li>
<li>Coordinates replication to secondaries</li>
<li>Ensures data consistency</li>
</ul>
<p><strong>3. Secondary Nodes (Blue):</strong></p>
<ul>
<li>Maintain synchronized copies of data</li>
<li>Send acknowledgments back to primary</li>
<li>Provide redundancy and failover capability</li>
</ul>
<p><strong>4. Data Flow:</strong></p>
<ul>
<li>Solid lines: Write propagation from primary to secondaries</li>
<li>Dotted lines: Acknowledgment messages back to primary</li>
<li>Final dotted line: Success confirmation to client</li>
</ul>
<p>This architecture ensures data consistency and fault tolerance through synchronized replication.</p>
<h3 id="asynchronous-replication" class="anchored">2. Asynchronous Replication</h3>
<p>Asynchronous replication prioritizes write performance over strict consistency. The primary server writes data without waiting for confirmation from secondary servers. Secondary servers update themselves periodically or based on events.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High write performance:</strong> Write operations are much faster as they don’t wait for replication.</li>
<li><strong>Improved scalability:</strong> Adding or removing secondary servers has minimal impact on performance.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Data inconsistency:</strong> Data might be inconsistent across replicas for a short period.</li>
<li><strong>Data loss risk:</strong> If the primary server fails before data is replicated, data loss can occur.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
        P -.-&gt;|Immediate Success| W
    end

    subgraph Primary
        P[Primary Node]
    end

    subgraph Async Replication
        P --&gt; |Async| S1[Secondary 1]
        P --&gt; |Async| S2[Secondary 2]
        P --&gt; |Async| S3[Secondary 3]
    end

    subgraph Status Updates
        S1 -.-&gt;|Replication Status| P
        S2 -.-&gt;|Replication Status| P
        S3 -.-&gt;|Replication Status| P
    end

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#9cf,stroke:#333
    style S3 fill:#9cf,stroke:#333
    style W fill:#f9f,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram shows:</p>
<p><strong>1. Write Flow (Pink):</strong></p>
<ul>
<li>Client sends write request to Primary</li>
<li>Primary confirms immediately, without waiting for secondaries</li>
</ul>
<p><strong>2. Primary Node (Orange):</strong></p>
<ul>
<li>Handles incoming writes</li>
<li>Propagates changes asynchronously to secondaries</li>
</ul>
<p><strong>3. Secondary Nodes (Blue):</strong></p>
<ul>
<li>Receive updates asynchronously</li>
<li>Send periodic status updates to Primary</li>
<li>May lag behind Primary</li>
</ul>
<p>This design prioritizes write performance over immediate consistency.</p>
<h3 id="semi-synchronous-replication" class="anchored">3. Semi-Synchronous Replication</h3>
<p>Semi-synchronous replication offers a compromise between synchronous and asynchronous replication. The primary server waits for confirmation from at least one secondary server before acknowledging the write operation.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>Improved write performance:</strong> Faster than synchronous replication.</li>
<li><strong>Enhanced data durability:</strong> Better data protection than asynchronous replication.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Potential for data inconsistency:</strong> If the only confirmed secondary server fails before replicating to other servers, inconsistency may arise.</li>
<li><strong>Performance can degrade if confirmed secondary servers are unavailable</strong></li>
</ul>
<p><strong>Diagram:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph TB
    subgraph Write Flow
        W((Write Request)) --&gt; P
    end

    subgraph Primary
        P[Primary Node]
    end

    subgraph Required Sync
        P --&gt; |Sync| S1[Secondary 1]
        S1 -.-&gt;|Acknowledge| P
    end

    subgraph Async Replicas
        P --&gt; |Async| S2[Secondary 2]
        P --&gt; |Async| S3[Secondary 3]
        S2 -.-&gt;|Status Update| P
        S3 -.-&gt;|Status Update| P
    end

    P -.-&gt;|Success after S1| W

    style P fill:#f96,stroke:#333,stroke-width:2px
    style S1 fill:#9cf,stroke:#333
    style S2 fill:#ddd,stroke:#333
    style S3 fill:#ddd,stroke:#333
    style W fill:#f9f,stroke:#333

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram illustrates:</p>
<p><strong>1. Write Process:</strong></p>
<ul>
<li>Client sends write request to Primary (Orange)</li>
<li>Primary syncs with Secondary 1 (Blue)</li>
<li>Secondary 1 must acknowledge before success</li>
</ul>
<p><strong>2. Secondary Nodes:</strong></p>
<ul>
<li>Secondary 1: Synchronous replication, required for write confirmation</li>
<li>Secondary 2 &amp; 3 (Gray): Asynchronous updates, not required for confirmation</li>
</ul>
<p><strong>3. Success Flow:</strong></p>
<ul>
<li>Write confirmed after Primary and Secondary 1 sync</li>
<li>Provides balance between data safety and performance</li>
<li>Other secondaries update eventually</li>
</ul>
<p>This hybrid approach ensures at least one backup is current while maintaining reasonable write speeds.</p>
<h3 id="multi-master-replication" class="anchored">4. Multi-Master Replication</h3>
<p>In multi-master replication, multiple servers can act as primary servers, accepting writes independently. Conflict resolution mechanisms are required to ensure data consistency across all replicas.</p>
<p><strong>Advantages:</strong></p>
<ul>
<li><strong>High availability:</strong> Writes can be accepted even if some servers are unavailable.</li>
<li><strong>Geographic distribution:</strong> Ideal for geographically distributed applications.</li>
</ul>
<p><strong>Disadvantages:</strong></p>
<ul>
<li><strong>Complex conflict resolution:</strong> Requires sophisticated mechanisms to handle concurrent writes.</li>
<li><strong>Increased complexity:</strong> Managing multiple masters increases operational overhead.</li>
</ul>
<p><strong>Diagram:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[Master Server 1] --&gt; B(Replica);
    C[Master Server 2] --&gt; B;
    D[Master Server 3] --&gt; B;
    A -.-&gt; C;
    A -.-&gt; D;
    C -.-&gt; A;
    C -.-&gt; D;
    D -.-&gt; A;
    D -.-&gt; C;
    style A fill:#ccf,stroke:#333,stroke-width:2px
    style C fill:#ccf,stroke:#333,stroke-width:2px
    style D fill:#ccf,stroke:#333,stroke-width:2px

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Here’s the information presented in a markdown table format, followed by a more detailed explanation:</p>
<h2 id="choosing-the-right-replication-strategy" class="anchored">Choosing the Right Replication Strategy</h2>
<table class="caption-top">
<colgroup>
<col style="width: 19%">
<col style="width: 80%">
</colgroup>
<thead>
<tr class="header">
<th style="text-align: left;">Factor</th>
<th style="text-align: left;">Key Considerations</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td style="text-align: left;"><strong>Data consistency</strong></td>
<td style="text-align: left;">How crucial is it that all replicas reflect the same data at all times (strong vs.&nbsp;eventual consistency)?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Performance needs</strong></td>
<td style="text-align: left;">How much latency can be tolerated for reads and writes? Is fast read access prioritized over write performance or vice versa?</td>
</tr>
<tr class="odd">
<td style="text-align: left;"><strong>Availability requirements</strong></td>
<td style="text-align: left;">How much downtime can the system afford? Is high availability essential?</td>
</tr>
<tr class="even">
<td style="text-align: left;"><strong>Cost considerations</strong></td>
<td style="text-align: left;">What are the associated infrastructure, resource, and maintenance costs of each replication strategy?</td>
</tr>
</tbody>
</table>
<h4 id="data-consistency-requirements" class="anchored">1. <strong>Data Consistency Requirements</strong></h4>
<p>When choosing a replication strategy, one of the most critical considerations is <strong>data consistency</strong>—the guarantee that all replicas reflect the same data. Two main types of consistency are:</p>
<ul>
<li><p><strong>Strong consistency</strong>: Ensures that once data is written to a primary node, all replicas immediately reflect that update. This is ideal for systems that require accurate, up-to-the-second data (e.g., financial transactions), but may come with higher latency as the system waits for all replicas to sync.</p></li>
<li><p><strong>Eventual consistency</strong>: Guarantees that replicas will eventually sync up, but not immediately. This strategy is more scalable and performs better for applications where real-time consistency is not critical, such as social media or e-commerce product catalogs.</p></li>
</ul>
<p>Choosing between these depends on how crucial it is that replicas remain synchronized at all times. For example, in mission-critical systems (like banking), strong consistency is often required. In contrast, in applications where slight delays in replica synchronization are acceptable (like social media posts), eventual consistency may be more suitable.</p>
<h4 id="performance-needs" class="anchored">2. <strong>Performance Needs</strong></h4>
<p>Performance is another key consideration in replication strategies:</p>
<ul>
<li><p><strong>Write performance</strong>: Replicating data across multiple nodes can introduce latency in write operations, especially in synchronous replication systems (where updates must be written to all replicas simultaneously). If your application needs to process a high volume of writes with minimal latency (e.g., real-time analytics), then a strategy that reduces replication overhead during writes is important.</p></li>
<li><p><strong>Read performance</strong>: In read-heavy systems, replication can significantly improve read performance by distributing requests across multiple replicas. For example, applications like content delivery networks (CDNs) can use replication to serve users from the nearest replica, reducing latency.</p></li>
</ul>
<p>In general, if the application is <strong>read-heavy</strong> (e.g., news sites or product search), replication strategies that optimize for read scalability (such as eventual consistency) can be beneficial. For <strong>write-heavy</strong> systems, synchronous replication may pose performance challenges and must be carefully considered.</p>
<h4 id="availability-requirements" class="anchored">3. <strong>Availability Requirements</strong></h4>
<p>Replication also plays a key role in ensuring <strong>high availability</strong>—the ability to keep the system operational even if individual nodes fail. Different replication strategies provide varying levels of fault tolerance and availability.</p>
<ul>
<li><p><strong>Synchronous replication</strong>: Writes are replicated to multiple nodes simultaneously, ensuring that any node failure doesn’t result in data loss. However, synchronous replication can increase latency and impact performance.</p></li>
<li><p><strong>Asynchronous replication</strong>: Writes are replicated to a primary node first, and then propagated to replicas later. This approach minimizes latency but increases the risk of data loss if the primary node fails before replication is complete.</p></li>
</ul>
<p>Systems with strict <strong>availability requirements</strong> (such as those needing 24/7 uptime) should favor strategies with strong fault tolerance. Asynchronous replication may be acceptable in less critical applications or where cost and performance are more important than immediate availability.</p>
<h4 id="cost-considerations" class="anchored">4. <strong>Cost Considerations</strong></h4>
<p>Each replication strategy comes with different cost implications:</p>
<ul>
<li><p><strong>Infrastructure costs</strong>: Maintaining multiple replicas requires additional hardware or cloud resources. More replicas (especially in a synchronous setup) can increase these costs substantially.</p></li>
<li><p><strong>Maintenance and complexity</strong>: More complex replication strategies (e.g., multi-region synchronous replication) introduce operational complexity. This can increase the need for skilled personnel, monitoring, and advanced tooling.</p></li>
</ul>
<p>When choosing a replication strategy, the trade-offs between cost and performance need to be evaluated. For instance, highly consistent, highly available systems with low latency may require significant investments in infrastructure, while eventual consistency strategies might be more affordable.</p>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>