<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Auto-scaling Systems – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-html-5276476b5bdb9cfe1f92c505466e0bf3.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Auto-scaling Systems – System Design Notes">
<meta property="og:site_name" content="System Design Notes">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Auto-scaling Systems</h1>

</header>


<p>Auto-scaling systems are the backbone of modern, resilient applications. They dynamically adjust the resources allocated to an application based on real-time demand, ensuring optimal performance while minimizing costs. This post will explore the intricacies of auto-scaling, covering various architectures, implementation strategies, and the key considerations for designing and deploying a robust auto-scaling solution.</p>
<h2 id="understanding-the-need-for-auto-scaling" class="anchored">Understanding the Need for Auto-Scaling</h2>
<p>Traditional approaches to resource allocation involve provisioning a fixed number of servers or virtual machines (VMs) based on predicted peak demand. This approach is inherently inefficient. During periods of low demand, resources are underutilized, leading to wasted costs. Conversely, during peak demand, insufficient resources can result in slowdowns, service disruptions, and a poor user experience.</p>
<p>Auto-scaling addresses this challenge by automatically adjusting the number of resources based on actual demand. This allows applications to handle fluctuating workloads gracefully, ensuring consistent performance while optimizing resource utilization and minimizing costs.</p>
<h2 id="key-components-of-an-auto-scaling-system" class="anchored">Key Components of an Auto-Scaling System</h2>
<p>A typical auto-scaling system consists of several key components:</p>
<ul>
<li><p><strong>Monitoring System:</strong> Continuously monitors various metrics, such as CPU utilization, memory usage, network traffic, request latency, and error rates. These metrics provide insights into the current system load and performance. Examples include Prometheus, Datadog, and CloudWatch.</p></li>
<li><p><strong>Scaling Logic:</strong> This component analyzes the metrics collected by the monitoring system and determines whether scaling up or down is necessary. It employs algorithms and rules to make scaling decisions based on predefined thresholds or sophisticated machine learning models.</p></li>
<li><p><strong>Provisioning System:</strong> This is responsible for adding or removing resources based on the scaling logic’s decisions. This can involve launching new VMs, containers, or serverless functions in the cloud or on-premise. Cloud providers offer managed auto-scaling services that handle this aspect, while on-premise systems often rely on orchestration tools like Kubernetes.</p></li>
<li><p><strong>Application Deployment:</strong> The application itself needs to be designed to handle dynamic changes in the number of instances. This often involves using load balancers to distribute traffic across available instances.</p></li>
</ul>
<h2 id="auto-scaling-architectures" class="anchored">Auto-Scaling Architectures</h2>
<p>Several architectural patterns are used for implementing auto-scaling:</p>
<p><strong>1. Vertical Scaling (Scaling Up):</strong> Increases the resources of an existing instance, such as increasing CPU, memory, or storage. This is simpler to implement but limited by the hardware capabilities of a single instance.</p>
<p><strong>2. Horizontal Scaling (Scaling Out):</strong> Adds or removes instances to handle the workload. This is the most common approach for auto-scaling and offers better scalability and resilience.</p>
<p><strong>Diagram illustrating Scaling:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph "Vertical Scaling"
        A[Small Instance] --&gt; B[Medium Instance]
        B --&gt; C[Large Instance]
    end

    subgraph "Horizontal Scaling"
        D[Load Balancer]
        D --&gt; E[Instance 1]
        D --&gt; F[Instance 2]
        D --&gt; G[Instance 3]
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Let me break down both scaling approaches shown in the diagram:</p>
<p>Vertical Scaling (Left):</p>
<ul>
<li>Shows a single instance growing in size/capacity</li>
<li>Three stages represented by differently-sized boxes</li>
<li>Progression from small (pink) → medium (light blue) → large (dark blue)</li>
<li>Resources like CPU, RAM, storage increase within the same instance</li>
</ul>
<p>Horizontal Scaling (Right):</p>
<ul>
<li>Features a load balancer (orange) at the top distributing traffic</li>
<li>Three identical instances (light blue) running in parallel</li>
<li>All instances have the same capacity/specifications</li>
<li>Traffic is split across multiple servers rather than upgrading a single server</li>
</ul>
<p>Key Differences Illustrated:</p>
<ul>
<li>Vertical focuses on growing one instance</li>
<li>Horizontal distributes load across multiple identical instances</li>
<li>Horizontal includes a load balancer for traffic distribution</li>
<li>Color intensity shows resource capacity differences in vertical scaling</li>
</ul>
<p><strong>3. Hybrid Scaling:</strong> Combines vertical and horizontal scaling to leverage the advantages of both approaches.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    LB[Load Balancer]
    
    subgraph "Cluster 1"
        LB --&gt; A1[Small Instance]
        A1 --&gt; B1[Medium Instance]
        B1 --&gt; C1[Large Instance]
    end
    
    subgraph "Cluster 2"
        LB --&gt; A2[Small Instance]
        A2 --&gt; B2[Medium Instance]
        B2 --&gt; C2[Large Instance]
    end
    
    subgraph "Cluster 3"
        LB --&gt; A3[Small Instance]
        A3 --&gt; B3[Medium Instance]
        B3 --&gt; C3[Large Instance]
    end

</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>Let me break down the hybrid scaling diagram:</p>
<p><strong>Load Balancer (Top):</strong></p>
<ul>
<li>Orange box distributing incoming traffic across multiple clusters</li>
<li>Acts as the entry point for all requests</li>
</ul>
<p><strong>Clusters (1, 2, and 3):</strong></p>
<ul>
<li>Each cluster shows vertical scaling capability</li>
<li>Progression: Small (pink) → Medium (light blue) → Large (dark blue)</li>
<li>All clusters are identical in structure</li>
<li>Can scale both up (vertically within cluster) and out (adding more clusters)</li>
</ul>
<p>Hybrid System can handle increased load by:</p>
<ol type="1">
<li>Scaling individual instances up within clusters</li>
<li>Adding more clusters when needed</li>
</ol>
<p>This provides better flexibility and fault tolerance which can optimize resource usage based on demand. This approach combines benefits of both vertical and horizontal scaling, allowing for more sophisticated capacity management.</p>
<h2 id="key-considerations-for-auto-scaling" class="anchored">Key Considerations for Auto-Scaling</h2>
<p>Auto-scaling is a critical mechanism for dynamically adjusting the resources available to an application in response to changing workloads. It ensures that applications maintain performance, minimize downtime, and control costs, particularly for cloud-based environments. Here is a more detailed look into the key considerations for effective auto-scaling:</p>
<h4 id="metrics-selection" class="anchored">1. <strong>Metrics Selection</strong></h4>
<p>Choosing the right metrics is foundational to implementing an efficient auto-scaling strategy. The metrics you monitor directly determine how and when scaling occurs.</p>
<ul>
<li><p><strong>CPU/Memory Utilization</strong>: This is a common metric for deciding when to scale. If CPU or memory usage consistently exceeds a set threshold, more instances are added. Conversely, underutilization might trigger downscaling.</p></li>
<li><p><strong>Request/Throughput Rate</strong>: For web applications, the number of requests per second (RPS) or network throughput is an important indicator of load. Sudden spikes in incoming traffic might necessitate additional resources to maintain performance.</p></li>
<li><p><strong>Custom Application Metrics</strong>: Depending on your application, custom metrics such as queue length, latency, or error rates can be more precise indicators. For example, in a messaging system, the length of a message queue might signal the need for additional processing power.</p></li>
</ul>
<p>Selecting accurate metrics ensures that the application scales responsively, avoiding over- or under-provisioning.</p>
<h4 id="scaling-policies" class="anchored">2. <strong>Scaling Policies</strong></h4>
<p>Scaling policies define the rules for when and how auto-scaling happens. Well-designed policies help ensure that the system remains efficient under varying loads:</p>
<ul>
<li><p><strong>Thresholds</strong>: Establish thresholds that dictate when scaling actions are triggered. For example, if CPU utilization exceeds 80% for a sustained period, new instances are spun up. Similarly, when utilization falls below a certain threshold, excess instances can be terminated to reduce costs.</p></li>
<li><p><strong>Cooldown Periods</strong>: Introduce cooldown periods to avoid over-scaling. After a scaling event, a cooldown period prevents the system from making further adjustments for a specified duration, allowing it to stabilize. Without a proper cooldown, the system may oscillate, frequently adding and removing instances in a way that undermines performance.</p></li>
<li><p><strong>Horizontal vs.&nbsp;Vertical Scaling</strong>: Horizontal scaling (adding more instances) is most common, but vertical scaling (increasing the size of existing instances) can also be considered for certain workloads. Policies should clearly define whether additional resources are provided by increasing instance count or upgrading instance capacity.</p></li>
</ul>
<h4 id="resource-limits" class="anchored">3. <strong>Resource Limits</strong></h4>
<p>Setting appropriate limits on the number of instances (both minimum and maximum) is essential to strike a balance between performance and cost management.</p>
<ul>
<li><p><strong>Minimum Limits</strong>: Setting a minimum number of instances ensures that there’s always a baseline capacity available to handle traffic. This avoids downtime or degraded performance during periods of lower traffic or unpredictable spikes.</p></li>
<li><p><strong>Maximum Limits</strong>: Implementing a maximum limit prevents the auto-scaling system from spawning too many instances during a traffic surge, which could result in unexpected costs. This is especially important if traffic spikes are brief, as excessive scaling could lead to resource waste.</p></li>
</ul>
<p>By controlling the minimum and maximum limits, you prevent runaway scaling that could either exhaust resources or result in exorbitant cloud bills.</p>
<h4 id="testing-and-monitoring" class="anchored">4. <strong>Testing and Monitoring</strong></h4>
<p>Auto-scaling is not a “set-it-and-forget-it” system; continuous testing and monitoring are crucial for ensuring it functions effectively:</p>
<ul>
<li><p><strong>Load Testing</strong>: Before deploying auto-scaling in production, it’s important to conduct rigorous load tests to simulate real-world traffic spikes and dips. This helps identify the scaling limits and ensure that the application can handle the predicted load with minimal latency and downtime.</p></li>
<li><p><strong>Monitoring Tools</strong>: Monitoring tools (such as Amazon CloudWatch, Prometheus, or Grafana) are essential to track resource usage and scaling events. By constantly monitoring metrics like instance count, CPU usage, and request rate, you can identify trends, optimize scaling policies, and detect problems early.</p></li>
<li><p><strong>Alerting</strong>: Set up alerting mechanisms that notify you of unusual scaling behaviors, such as sudden spikes in resource usage, to ensure that issues can be addressed before they affect users.</p></li>
</ul>
<h4 id="cost-optimization" class="anchored">5. <strong>Cost Optimization</strong></h4>
<p>Auto-scaling is designed to optimize performance, but without a well-thought-out strategy, it can quickly lead to higher operational costs. Here are some ways to minimize costs while benefiting from dynamic scaling:</p>
<ul>
<li><p><strong>Leverage Spot Instances</strong>: Spot instances, offered by cloud providers like AWS, are significantly cheaper than regular instances. These can be used for workloads that are tolerant to interruptions, helping to reduce costs when scaling out.</p></li>
<li><p><strong>Adjust Scaling Based on Time or Load Patterns</strong>: If you know when your application experiences peak traffic (e.g., daytime hours) or quiet periods (e.g., overnight), you can pre-adjust scaling policies to have more instances available during peak hours and scale down during off-peak times.</p></li>
<li><p><strong>Right-Sizing Instances</strong>: Choose the most cost-efficient instance sizes that match your application’s needs. Over-provisioning by using instances with too much CPU or memory can lead to unnecessary costs.</p></li>
<li><p><strong>Scheduled Scaling</strong>: In addition to auto-scaling, you can use scheduled scaling to preemptively add or remove instances based on predictable demand patterns (e.g., scaling up before a major event or promotion).</p></li>
</ul>
<p>By carefully managing these aspects, you can minimize resource usage while maintaining performance.</p>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>