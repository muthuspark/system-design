<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>Authorization Models – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
.display.math{display: block; text-align: center; margin: 0.5rem auto;}
</style>


<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../../site_libs/quarto-html/quarto-html-5276476b5bdb9cfe1f92c505466e0bf3.min.css" rel="stylesheet" append-hash="true" data-mode="light">
<link href="../../../site_libs/quarto-html/quarto-syntax-highlighting-e26003cea8cd680ca0c55a263523d882.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="Authorization Models – System Design Notes">
<meta property="og:site_name" content="System Design Notes">
</head>

<body>


<header id="title-block-header">
<h1 class="title">Authorization Models</h1>

</header>


<p>Authorization is a critical aspect of security, defining <em>what</em> a user or system is allowed to do after successful authentication (verifying their identity). It’s the gatekeeper that ensures only authorized entities can access specific resources and perform certain actions. This post explores various authorization models, their strengths and weaknesses, and how they are implemented.</p>
<h2 id="role-based-access-control-rbac" class="anchored">1. Role-Based Access Control (RBAC)</h2>
<p>RBAC is the most widely adopted model. It assigns permissions to roles, and users are assigned to those roles. This simplifies management, as permissions are managed at the role level, rather than individually for each user.</p>
<p><strong>Diagram:</strong></p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph Users[Users]
        U1[User 1]
        U2[User 2]
        U3[User 3]
    end

    subgraph Roles[Roles]
        Admin[Administrator]
        Manager[Manager]
        Staff[Staff]
    end

    subgraph Permissions[Permissions]
        P1[Create]
        P2[Read]
        P3[Update]
        P4[Delete]
    end

    subgraph Resources[Resources]
        R1[Files]
        R2[Applications]
        R3[Databases]
    end

    U1 --&gt;|Assigned to| Admin
    U2 --&gt;|Assigned to| Manager
    U3 --&gt;|Assigned to| Staff

    Admin --&gt;|Has| P1
    Admin --&gt;|Has| P2
    Admin --&gt;|Has| P3
    Admin --&gt;|Has| P4

    Manager --&gt;|Has| P1
    Manager --&gt;|Has| P2
    Manager --&gt;|Has| P3

    Staff --&gt;|Has| P2

    P1 --&gt;|Applies to| R1
    P1 --&gt;|Applies to| R2
    P1 --&gt;|Applies to| R3
    P2 --&gt;|Applies to| R1
    P2 --&gt;|Applies to| R2
    P2 --&gt;|Applies to| R3
    P3 --&gt;|Applies to| R1
    P3 --&gt;|Applies to| R2
    P3 --&gt;|Applies to| R3
    P4 --&gt;|Applies to| R1
    P4 --&gt;|Applies to| R2
    P4 --&gt;|Applies to| R3

    style Admin fill:#ff9999
    style Manager fill:#99ff99
    style Staff fill:#9999ff
    style U1 fill:#f9f9f9
    style U2 fill:#f9f9f9
    style U3 fill:#f9f9f9
    style P1 fill:#ffe6cc
    style P2 fill:#ffe6cc
    style P3 fill:#ffe6cc
    style P4 fill:#ffe6cc
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram shows RBAC’s hierarchical structure:</p>
<ol type="1">
<li>Users are assigned to specific roles (Admin, Manager, Staff)</li>
<li>Roles have predefined permissions (Create, Read, Update, Delete)</li>
<li>Permissions apply to resources (Files, Applications, Databases)</li>
<li>Administrators have full CRUD access</li>
<li>Managers can create, read, and update</li>
<li>Staff members have read-only access</li>
</ol>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Simplified management:</strong> Easier to manage permissions for large numbers of users.</li>
<li><strong>Granular control:</strong> Roles can be customized to precisely define permissions.</li>
<li><strong>Scalability:</strong> Well-suited for large organizations and complex systems.</li>
</ul>
<p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Role explosion:</strong> Too many roles can become difficult to manage.</li>
<li><strong>Inflexible:</strong> Difficult to handle exceptional cases that don’t fit neatly into roles.</li>
<li><strong>Static:</strong> Changes to roles often require system-wide updates.</li>
</ul>
<h2 id="attribute-based-access-control-abac" class="anchored">2. Attribute-Based Access Control (ABAC)</h2>
<p>ABAC is a more fine-grained model that uses attributes of the user, the resource, and the environment to determine access. This allows for highly dynamic and context-aware authorization decisions.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph Inputs
        U[User Context]
        E[Environment Context]
        R[Resource Context]
        A[Action Type]
    end

    subgraph Attributes
        SA[Subject Attributes]
        EA[Environment Attributes]
        RA[Resource Attributes]
    end

    subgraph PolicyEngine
        P[Policy Rules]
        AE[Authorization Engine]
    end

    subgraph Decision
        D{Evaluation}
        P1[Permit]
        D1[Deny]
    end

    U --&gt; SA
    E --&gt; EA
    R --&gt; RA
    
    SA --&gt; AE
    EA --&gt; AE
    RA --&gt; AE
    A --&gt; AE
    P --&gt; AE
    
    AE --&gt; D
    D --&gt;|Allow| P1
    D --&gt;|Reject| D1

    style U fill:#e6e6ff,stroke:#333
    style E fill:#e6e6ff,stroke:#333
    style R fill:#e6e6ff,stroke:#333
    style A fill:#e6e6ff,stroke:#333
    style AE fill:#d9d9ff,stroke:#333
    style P fill:#cce6ff,stroke:#333
    style P1 fill:#90EE90,stroke:#333
    style D1 fill:#FFB6C1,stroke:#333
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram shows:</p>
<ol type="1">
<li>Input Sources:
<ul>
<li>User Context (including attributes like age, name, role)</li>
<li>Environment Context (time, status, location)</li>
<li>Resource Context (classification, size, amount)</li>
<li>Action Type (read, delete, edit)</li>
</ul></li>
<li>Attribute Processing:
<ul>
<li>Subject Attributes derived from User Context</li>
<li>Environment Attributes from Environment Context</li>
<li>Resource Attributes from Resource Context</li>
</ul></li>
<li>Policy Engine:
<ul>
<li>Policy Rules defining access conditions</li>
<li>Authorization Engine that evaluates all inputs against policies</li>
</ul></li>
<li>Decision Flow:
<ul>
<li>Evaluation node that determines the final outcome</li>
<li>Permit (green) and Deny (red) outcomes</li>
</ul></li>
</ol>
<p>The diagram follows the principle of eliminating redundancy by:</p>
<ul>
<li>Centralizing the authorization logic in a single engine</li>
<li>Using attribute-based access control to avoid duplicating rules</li>
<li>Standardizing the decision flow process</li>
</ul>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Fine-grained control:</strong> Highly flexible and adaptable to changing requirements.</li>
<li><strong>Context-aware:</strong> Decisions based on user attributes, resource attributes, and environment conditions.</li>
<li><strong>Scalability:</strong> Can handle complex scenarios and large numbers of users and resources.</li>
</ul>
<p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Complexity:</strong> More complex to implement and manage than RBAC.</li>
<li><strong>Performance:</strong> Policy evaluation can be computationally expensive.</li>
<li><strong>Policy management:</strong> Requires sophisticated policy management tools.</li>
</ul>
<h2 id="access-control-lists-acls" class="anchored">3. Access Control Lists (ACLs)</h2>
<p>ACLs are a simple model where each resource has a list of users or groups and the permissions they have for that resource.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart LR
    subgraph Users
        U1[User 1]
        U2[User 2]
        U3[User 3]
    end

    subgraph ACL["ACL Rules"]
        R1["Permit IP/Port"]
        R2["Deny IP/Port"]
    end

    subgraph Services
        S1[Email Port 443]
        S2[Gmail]
        S3[Other Services]
    end

    U1 --&gt; R1
    U2 --&gt; R1
    U3 --&gt; R2
    
    R1 --&gt;|Allow| S1
    R1 --&gt;|Allow| S2
    R2 --&gt;|Block| S3

    style U1 fill:#99ccff
    style U2 fill:#99ccff
    style U3 fill:#99ccff
    style R1 fill:#90EE90
    style R2 fill:#FFB6C1
    style S1 fill:#e6e6ff
    style S2 fill:#e6e6ff
    style S3 fill:#e6e6ff
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram shows ACL configuration with permit/deny rules controlling user access to network services. Green represents permitted access, red shows denied access, and blue indicates users and services.</p>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Simplicity:</strong> Easy to understand and implement.</li>
<li><strong>Direct access control:</strong> Explicitly defines permissions for each resource.</li>
</ul>
<p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Scalability:</strong> Difficult to manage for a large number of users and resources.</li>
<li><strong>Maintenance:</strong> Requires significant effort to manage changes in permissions.</li>
<li><strong>Lack of granularity:</strong> Limited ability to handle complex access scenarios.</li>
</ul>
<h2 id="ownership-based-access-control-obac" class="anchored">4. Ownership-Based Access Control (OBAC)</h2>
<p>OBAC is centered around the concept of ownership. The owner of a resource has full control over it, and can grant permissions to others. This is often combined with other models to provide a more robust system.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class=""><p></p>
<div>
<pre class="mermaid mermaid-js">flowchart TD
    subgraph Users
        O[Owner]
        D[Delegated Users]
        R[Regular Users]
    end

    subgraph Resources
        Doc[Documents]
        Proj[Projects]
        Data[Data Sets]
    end

    subgraph Permissions
        Full[Full Control]
        Edit[Edit Rights]
        View[View Only]
    end

    O --&gt;|Has| Full
    D --&gt;|Granted| Edit
    R --&gt;|Given| View

    Full --&gt;|Complete Access| Doc
    Full --&gt;|Complete Access| Proj
    Full --&gt;|Complete Access| Data

    Edit --&gt;|Modify| Doc
    Edit --&gt;|Modify| Proj
    Edit --&gt;|Modify| Data

    View --&gt;|Read| Doc
    View --&gt;|Read| Proj
    View --&gt;|Read| Data

    O --&gt;|Can Delegate| D

    style O fill:#ff9999
    style D fill:#99ff99
    style R fill:#9999ff
    style Full fill:#ff9999
    style Edit fill:#99ff99
    style View fill:#9999ff
    style Doc fill:#f9f9f9
    style Proj fill:#f9f9f9
    style Data fill:#f9f9f9
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>The diagram illustrates how Ownership-Based Access Control (OBAC) works:</p>
<ol type="1">
<li>User Hierarchy:</li>
</ol>
<ul>
<li>Owners (red) have highest level access and can delegate rights</li>
<li>Delegated users (green) receive edit permissions from owners</li>
<li>Regular users (blue) have basic view access</li>
</ul>
<ol start="2" type="1">
<li>Permission Levels:</li>
</ol>
<ul>
<li>Full Control: Complete access to all resources</li>
<li>Edit Rights: Ability to modify resources</li>
<li>View Only: Read-only access</li>
</ul>
<ol start="3" type="1">
<li>Resources Protected:</li>
</ol>
<ul>
<li>Documents</li>
<li>Projects</li>
<li>Data Sets</li>
</ul>
<ol start="4" type="1">
<li>Key Relationships:</li>
</ol>
<ul>
<li>Owners can delegate permissions to other users</li>
<li>Each permission level cascades to all resource types</li>
<li>Users can only perform actions within their assigned permission level</li>
</ul>
<p>This model emphasizes resource ownership as the basis for access control decisions, with clear hierarchical permissions structure.</p>
<p><strong>Strengths:</strong></p>
<ul>
<li><strong>Intuitive:</strong> Simple to grasp and often aligns with users’ expectations.</li>
<li><strong>Simple implementation:</strong> Relatively straightforward to implement.</li>
</ul>
<p><strong>Weaknesses:</strong></p>
<ul>
<li><strong>Potential for conflicts:</strong> Can lead to conflicts if ownership is not clearly defined.</li>
<li><strong>Limited granularity:</strong> May not provide the fine-grained control needed in complex systems.</li>
</ul>


<script id="quarto-html-after-body" type="application/javascript">
window.document.addEventListener("DOMContentLoaded", function (event) {
  const toggleBodyColorMode = (bsSheetEl) => {
    const mode = bsSheetEl.getAttribute("data-mode");
    const bodyEl = window.document.querySelector("body");
    if (mode === "dark") {
      bodyEl.classList.add("quarto-dark");
      bodyEl.classList.remove("quarto-light");
    } else {
      bodyEl.classList.add("quarto-light");
      bodyEl.classList.remove("quarto-dark");
    }
  }
  const toggleBodyColorPrimary = () => {
    const bsSheetEl = window.document.querySelector("link#quarto-bootstrap");
    if (bsSheetEl) {
      toggleBodyColorMode(bsSheetEl);
    }
  }
  toggleBodyColorPrimary();  
  const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
  tabsets.forEach(function(tabset) {
    const tabby = new Tabby('#' + tabset.id);
  });
  const icon = "";
  const anchorJS = new window.AnchorJS();
  anchorJS.options = {
    placement: 'right',
    icon: icon
  };
  anchorJS.add('.anchored');
  const isCodeAnnotation = (el) => {
    for (const clz of el.classList) {
      if (clz.startsWith('code-annotation-')) {                     
        return true;
      }
    }
    return false;
  }
  const onCopySuccess = function(e) {
    // button target
    const button = e.trigger;
    // don't keep focus
    button.blur();
    // flash "checked"
    button.classList.add('code-copy-button-checked');
    var currentTitle = button.getAttribute("title");
    button.setAttribute("title", "Copied!");
    let tooltip;
    if (window.bootstrap) {
      button.setAttribute("data-bs-toggle", "tooltip");
      button.setAttribute("data-bs-placement", "left");
      button.setAttribute("data-bs-title", "Copied!");
      tooltip = new bootstrap.Tooltip(button, 
        { trigger: "manual", 
          customClass: "code-copy-button-tooltip",
          offset: [0, -8]});
      tooltip.show();    
    }
    setTimeout(function() {
      if (tooltip) {
        tooltip.hide();
        button.removeAttribute("data-bs-title");
        button.removeAttribute("data-bs-toggle");
        button.removeAttribute("data-bs-placement");
      }
      button.setAttribute("title", currentTitle);
      button.classList.remove('code-copy-button-checked');
    }, 1000);
    // clear code selection
    e.clearSelection();
  }
  const getTextToCopy = function(trigger) {
      const codeEl = trigger.previousElementSibling.cloneNode(true);
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
  }
  const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
    text: getTextToCopy
  });
  clipboard.on('success', onCopySuccess);
  if (window.document.getElementById('quarto-embedded-source-code-modal')) {
    const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
      text: getTextToCopy,
      container: window.document.getElementById('quarto-embedded-source-code-modal')
    });
    clipboardModal.on('success', onCopySuccess);
  }
    var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
    var mailtoRegex = new RegExp(/^mailto:/);
      var filterRegex = new RegExp("https:\/\/system-design\.muthu\.co\/");
    var isInternal = (href) => {
        return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
    }
    // Inspect non-navigation links and adorn them if external
 	var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
    for (var i=0; i<links.length; i++) {
      const link = links[i];
      if (!isInternal(link.href)) {
        // undo the damage that might have been done by quarto-nav.js in the case of
        // links that we want to consider external
        if (link.dataset.originalHref !== undefined) {
          link.href = link.dataset.originalHref;
        }
      }
    }
  function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
    const config = {
      allowHTML: true,
      maxWidth: 500,
      delay: 100,
      arrow: false,
      appendTo: function(el) {
          return el.parentElement;
      },
      interactive: true,
      interactiveBorder: 10,
      theme: 'light-border',
      placement: 'bottom-start',
    };
    if (contentFn) {
      config.content = contentFn;
    }
    if (onTriggerFn) {
      config.onTrigger = onTriggerFn;
    }
    if (onUntriggerFn) {
      config.onUntrigger = onUntriggerFn;
    }
    window.tippy(el, config); 
  }
  const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
  for (var i=0; i<noterefs.length; i++) {
    const ref = noterefs[i];
    tippyHover(ref, function() {
      // use id or data attribute instead here
      let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
      try { href = new URL(href).hash; } catch {}
      const id = href.replace(/^#\/?/, "");
      const note = window.document.getElementById(id);
      if (note) {
        return note.innerHTML;
      } else {
        return "";
      }
    });
  }
  const xrefs = window.document.querySelectorAll('a.quarto-xref');
  const processXRef = (id, note) => {
    // Strip column container classes
    const stripColumnClz = (el) => {
      el.classList.remove("page-full", "page-columns");
      if (el.children) {
        for (const child of el.children) {
          stripColumnClz(child);
        }
      }
    }
    stripColumnClz(note)
    if (id === null || id.startsWith('sec-')) {
      // Special case sections, only their first couple elements
      const container = document.createElement("div");
      if (note.children && note.children.length > 2) {
        container.appendChild(note.children[0].cloneNode(true));
        for (let i = 1; i < note.children.length; i++) {
          const child = note.children[i];
          if (child.tagName === "P" && child.innerText === "") {
            continue;
          } else {
            container.appendChild(child.cloneNode(true));
            break;
          }
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(container);
        }
        return container.innerHTML
      } else {
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        return note.innerHTML;
      }
    } else {
      // Remove any anchor links if they are present
      const anchorLink = note.querySelector('a.anchorjs-link');
      if (anchorLink) {
        anchorLink.remove();
      }
      if (window.Quarto?.typesetMath) {
        window.Quarto.typesetMath(note);
      }
      if (note.classList.contains("callout")) {
        return note.outerHTML;
      } else {
        return note.innerHTML;
      }
    }
  }
  for (var i=0; i<xrefs.length; i++) {
    const xref = xrefs[i];
    tippyHover(xref, undefined, function(instance) {
      instance.disable();
      let url = xref.getAttribute('href');
      let hash = undefined; 
      if (url.startsWith('#')) {
        hash = url;
      } else {
        try { hash = new URL(url).hash; } catch {}
      }
      if (hash) {
        const id = hash.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note !== null) {
          try {
            const html = processXRef(id, note.cloneNode(true));
            instance.setContent(html);
          } finally {
            instance.enable();
            instance.show();
          }
        } else {
          // See if we can fetch this
          fetch(url.split('#')[0])
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.getElementById(id);
            if (note !== null) {
              const html = processXRef(id, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      } else {
        // See if we can fetch a full url (with no hash to target)
        // This is a special case and we should probably do some content thinning / targeting
        fetch(url)
        .then(res => res.text())
        .then(html => {
          const parser = new DOMParser();
          const htmlDoc = parser.parseFromString(html, "text/html");
          const note = htmlDoc.querySelector('main.content');
          if (note !== null) {
            // This should only happen for chapter cross references
            // (since there is no id in the URL)
            // remove the first header
            if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
              note.children[0].remove();
            }
            const html = processXRef(null, note);
            instance.setContent(html);
          } 
        }).finally(() => {
          instance.enable();
          instance.show();
        });
      }
    }, function(instance) {
    });
  }
      let selectedAnnoteEl;
      const selectorForAnnotation = ( cell, annotation) => {
        let cellAttr = 'data-code-cell="' + cell + '"';
        let lineAttr = 'data-code-annotation="' +  annotation + '"';
        const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
        return selector;
      }
      const selectCodeLines = (annoteEl) => {
        const doc = window.document;
        const targetCell = annoteEl.getAttribute("data-target-cell");
        const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
        const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
        const lines = annoteSpan.getAttribute("data-code-lines").split(",");
        const lineIds = lines.map((line) => {
          return targetCell + "-" + line;
        })
        let top = null;
        let height = null;
        let parent = null;
        if (lineIds.length > 0) {
            //compute the position of the single el (top and bottom and make a div)
            const el = window.document.getElementById(lineIds[0]);
            top = el.offsetTop;
            height = el.offsetHeight;
            parent = el.parentElement.parentElement;
          if (lineIds.length > 1) {
            const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
            const bottom = lastEl.offsetTop + lastEl.offsetHeight;
            height = bottom - top;
          }
          if (top !== null && height !== null && parent !== null) {
            // cook up a div (if necessary) and position it 
            let div = window.document.getElementById("code-annotation-line-highlight");
            if (div === null) {
              div = window.document.createElement("div");
              div.setAttribute("id", "code-annotation-line-highlight");
              div.style.position = 'absolute';
              parent.appendChild(div);
            }
            div.style.top = top - 2 + "px";
            div.style.height = height + 4 + "px";
            div.style.left = 0;
            let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
            if (gutterDiv === null) {
              gutterDiv = window.document.createElement("div");
              gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
              gutterDiv.style.position = 'absolute';
              const codeCell = window.document.getElementById(targetCell);
              const gutter = codeCell.querySelector('.code-annotation-gutter');
              gutter.appendChild(gutterDiv);
            }
            gutterDiv.style.top = top - 2 + "px";
            gutterDiv.style.height = height + 4 + "px";
          }
          selectedAnnoteEl = annoteEl;
        }
      };
      const unselectCodeLines = () => {
        const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
        elementsIds.forEach((elId) => {
          const div = window.document.getElementById(elId);
          if (div) {
            div.remove();
          }
        });
        selectedAnnoteEl = undefined;
      };
        // Handle positioning of the toggle
    window.addEventListener(
      "resize",
      throttle(() => {
        elRect = undefined;
        if (selectedAnnoteEl) {
          selectCodeLines(selectedAnnoteEl);
        }
      }, 10)
    );
    function throttle(fn, ms) {
    let throttle = false;
    let timer;
      return (...args) => {
        if(!throttle) { // first call gets through
            fn.apply(this, args);
            throttle = true;
        } else { // all the others get throttled
            if(timer) clearTimeout(timer); // cancel #2
            timer = setTimeout(() => {
              fn.apply(this, args);
              timer = throttle = false;
            }, ms);
        }
      };
    }
      // Attach click handler to the DT
      const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
      for (const annoteDlNode of annoteDls) {
        annoteDlNode.addEventListener('click', (event) => {
          const clickedEl = event.target;
          if (clickedEl !== selectedAnnoteEl) {
            unselectCodeLines();
            const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
            if (activeEl) {
              activeEl.classList.remove('code-annotation-active');
            }
            selectCodeLines(clickedEl);
            clickedEl.classList.add('code-annotation-active');
          } else {
            // Unselect the line
            unselectCodeLines();
            clickedEl.classList.remove('code-annotation-active');
          }
        });
      }
  const findCites = (el) => {
    const parentEl = el.parentElement;
    if (parentEl) {
      const cites = parentEl.dataset.cites;
      if (cites) {
        return {
          el,
          cites: cites.split(' ')
        };
      } else {
        return findCites(el.parentElement)
      }
    } else {
      return undefined;
    }
  };
  var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
  for (var i=0; i<bibliorefs.length; i++) {
    const ref = bibliorefs[i];
    const citeInfo = findCites(ref);
    if (citeInfo) {
      tippyHover(citeInfo.el, function() {
        var popup = window.document.createElement('div');
        citeInfo.cites.forEach(function(cite) {
          var citeDiv = window.document.createElement('div');
          citeDiv.classList.add('hanging-indent');
          citeDiv.classList.add('csl-entry');
          var biblioDiv = window.document.getElementById('ref-' + cite);
          if (biblioDiv) {
            citeDiv.innerHTML = biblioDiv.innerHTML;
          }
          popup.appendChild(citeDiv);
        });
        return popup.innerHTML;
      });
    }
  }
});
</script>




</body></html>