<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.6.39">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">


<title>API Caching – System Design Notes</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
/* CSS for syntax highlighting */
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { display: inline-block; text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
  }
pre.numberSource { margin-left: 3em;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
</style>


<script src="../../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../../">
<link href="../../../favicon.ico" rel="icon">
<script src="../../../site_libs/quarto-html/quarto.js"></script>
<script src="../../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../../site_libs/bootstrap/bootstrap-5c1aa57916d092647891b8a3fe59897e.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>
<meta name="mermaid-theme" content="neutral">
<script src="../../../site_libs/quarto-diagram/mermaid.min.js"></script>
<script src="../../../site_libs/quarto-diagram/mermaid-init.js"></script>
<link href="../../../site_libs/quarto-diagram/mermaid.css" rel="stylesheet">


<link rel="stylesheet" href="../../../styles.css">
<meta property="og:title" content="API Caching – System Design Notes">
<meta property="og:description" content="">
<meta property="og:site_name" content="System Design Notes">
</head>

<body class="nav-fixed fullcontent">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a class="navbar-brand" href="../../../index.html">
    <span class="navbar-title">System Design Notes</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/muthuspark"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com/krimuthu"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
  <a href="" class="quarto-reader-toggle quarto-navigation-tool px-1" onclick="window.quartoToggleReader(); return false;" title="Toggle reader mode">
  <div class="quarto-reader-toggle-btn">
  <i class="bi"></i>
  </div>
</a>
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content" id="quarto-document-content">

<header id="title-block-header" class="quarto-title-block default">
<div class="quarto-title">
<h1 class="title">API Caching</h1>
  <div class="quarto-categories">
    <div class="quarto-category">API Design</div>
  </div>
  </div>



<div class="quarto-title-meta">

    
  
    
  </div>
  


</header>


<p>API caching is a crucial technique for optimizing the performance and scalability of applications that rely heavily on external APIs. By storing responses from API calls, you can significantly reduce latency, lower the load on your servers, and minimize costs associated with API requests. This post will delve into the intricacies of API caching, exploring different strategies, implementation techniques, and best practices.</p>
<section id="understanding-the-need-for-api-caching" class="level2">
<h2 data-anchor-id="understanding-the-need-for-api-caching">Understanding the Need for API Caching</h2>
<p>Imagine your application fetches data frequently from a slow or expensive third-party API. Every time a user requests this data, your application makes a fresh API call, leading to several problems:</p>
<ul>
<li><strong>Increased Latency:</strong> Network requests and API processing times introduce delays, resulting in a poor user experience.</li>
<li><strong>Server Overload:</strong> Frequent API calls can overwhelm your servers, potentially leading to crashes or performance degradation.</li>
<li><strong>Increased Costs:</strong> Many APIs charge based on the number of requests. Frequent calls translate directly into higher costs.</li>
</ul>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[User Request] --&gt; B(Application);
    B --&gt; C{API Call};
    C -- Success --&gt; D(API Response);
    D --&gt; B;
    B --&gt; E[User Response];
    subgraph Slow and Expensive
        C;
    end
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>This diagram illustrates the traditional approach without caching. The user request triggers an API call, resulting in a potentially slow and expensive process. Caching aims to alleviate these issues.</p>
</section>
<section id="types-of-api-caching" class="level2">
<h2 data-anchor-id="types-of-api-caching">Types of API Caching</h2>
<p>Several caching strategies exist, each with its strengths and weaknesses:</p>
<p><strong>1. Client-Side Caching:</strong> The cache resides within the user’s browser or application. This reduces the number of API calls, but the cached data might become stale.</p>
<p><strong>2. Server-Side Caching:</strong> The cache resides on your application’s server. This offers more control and allows for sophisticated caching strategies.</p>
<p><strong>3. CDN (Content Delivery Network) Caching:</strong> A CDN acts as a distributed cache, serving static content closer to users. This minimizes latency and improves performance for geographically dispersed users.</p>
<div class="cell" data-layout-align="default">
<div class="cell-output-display">
<div>
<p></p><figure class="figure"><p></p>
<div>
<pre class="mermaid mermaid-js">graph LR
    A[User Request] --&gt; B(Client-Side Cache);
    B -- Cache Hit --&gt; E[User Response];
    B -- Cache Miss --&gt; C(Application);
    C --&gt; D{API Call};
    D -- Success --&gt; C;
    C --&gt; B;
    C --&gt; E;
</pre>
</div>
<p></p></figure><p></p>
</div>
</div>
</div>
<p>This diagram shows a simple client-side caching scenario. If the data is found in the cache (cache hit), it is served directly; otherwise (cache miss), a fresh API call is made.</p>
</section>
<section id="implementing-server-side-caching" class="level2">
<h2 data-anchor-id="implementing-server-side-caching">Implementing Server-Side Caching</h2>
<p>Server-side caching is a powerful technique offering granular control. Popular caching mechanisms include:</p>
<ul>
<li><strong>Memory Caching (e.g., Redis, Memcached):</strong> Fast in-memory caches offer excellent performance but data is lost on server restart.</li>
<li><strong>Disk Caching (e.g., local file system, database):</strong> More persistent than memory caching, but slower.</li>
<li><strong>Dedicated Caching Services (e.g., Amazon ElastiCache, Redis Enterprise Cloud):</strong> Managed services that simplify caching management and scalability.</li>
</ul>
<p>Let’s consider a simple example using Python and Redis:</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode python"><code class="sourceCode python"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="im">import</span> redis</span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a>r <span class="op">=</span> redis.Redis(host<span class="op">=</span><span class="st">'localhost'</span>, port<span class="op">=</span><span class="dv">6379</span>, db<span class="op">=</span><span class="dv">0</span>)</span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> get_data_from_api(url):</span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a>  <span class="co"># Simulate an API call (replace with actual API call)</span></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a>  <span class="co"># ...</span></span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a>  <span class="cf">return</span> {<span class="st">"data"</span>: <span class="st">"from API"</span>}</span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a><span class="kw">def</span> cached_api_call(url, cache_key):</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>    cached_data <span class="op">=</span> r.get(cache_key)</span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>    <span class="cf">if</span> cached_data:</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> cached_data.decode(<span class="st">'utf-8'</span>)</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>    <span class="cf">else</span>:</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a>        data <span class="op">=</span> get_data_from_api(url)</span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a>        r.<span class="bu">set</span>(cache_key, data)</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>        <span class="cf">return</span> data</span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>url <span class="op">=</span> <span class="st">"https://example.com/api/data"</span></span>
<span id="cb1-22"><a href="#cb1-22" aria-hidden="true" tabindex="-1"></a>cache_key <span class="op">=</span> <span class="st">"example_api_data"</span></span>
<span id="cb1-23"><a href="#cb1-23" aria-hidden="true" tabindex="-1"></a>data <span class="op">=</span> cached_api_call(url, cache_key)</span>
<span id="cb1-24"><a href="#cb1-24" aria-hidden="true" tabindex="-1"></a><span class="bu">print</span>(data)</span></code></pre></div>
<p>This code snippet demonstrates a basic caching strategy using Redis. The <code>cached_api_call</code> function first checks for cached data; if not found, it fetches data from the API, stores it in the cache, and returns it.</p>
</section>
<section id="cache-invalidation-strategies" class="level2">
<h2 data-anchor-id="cache-invalidation-strategies">Cache Invalidation Strategies</h2>
<p>Data changes over time. Strategies for removing stale data from the cache are crucial:</p>
<ul>
<li><strong>Time-Based Expiry:</strong> Setting an expiration time for cached data.</li>
<li><strong>Cache-Aside Pattern:</strong> The application always checks the cache first, and if the data is missing or stale, it updates the cache.</li>
<li><strong>Write-Through Caching:</strong> Data is written to both the cache and the source simultaneously.</li>
<li><strong>Write-Back Caching:</strong> Data is written to the cache first, and asynchronously to the source.</li>
</ul>
</section>
<section id="best-practices-for-api-caching" class="level2">
<h2 data-anchor-id="best-practices-for-api-caching">Best Practices for API Caching</h2>
<ul>
<li><strong>Choose the Right Caching Strategy:</strong> Consider the characteristics of your API and application requirements.</li>
<li><strong>Effective Cache Keys:</strong> Design clear and unambiguous cache keys to avoid collisions.</li>
<li><strong>Cache Invalidation Strategy:</strong> Implement a robust invalidation strategy to prevent stale data.</li>
<li><strong>Monitor Cache Performance:</strong> Track cache hits, misses, and eviction rates to optimize performance.</li>
<li><strong>Handle Errors Gracefully:</strong> Implement error handling for cache failures and API errors.</li>
</ul>


</section>

</main> <!-- /main -->
</div> <!-- /content -->
<footer class="footer">
  <div class="nav-footer">
    <div class="nav-footer-left">
<p>“Copyright 2025, Muthukrishnan”</p>
</div>   
    <div class="nav-footer-center">
      &nbsp;
    </div>
    <div class="nav-footer-right">
      &nbsp;
    </div>
  </div>
</footer>




</body></html>